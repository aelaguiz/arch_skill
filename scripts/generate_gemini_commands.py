#!/usr/bin/env python3
from __future__ import annotations

import argparse
import os
import re
from dataclasses import dataclass
from pathlib import Path


PROMPTS_DIR_DEFAULT = "prompts"
OUTPUT_DIR_DEFAULT = "gemini/commands/prompts"
GEMINI_INSTALLED_PROMPTS_DIR = "~/.gemini/arch_skill/prompts"


@dataclass(frozen=True)
class PromptInfo:
    name: str
    description: str


def _toml_escape_string(value: str) -> str:
    return value.replace("\\", "\\\\").replace('"', '\\"')


def _strip_surrounding_quotes(value: str) -> str:
    value = value.strip()
    if len(value) >= 2 and value[0] == value[-1] and value[0] in ('"', "'"):
        return value[1:-1]
    return value


def _parse_description_from_frontmatter(markdown: str) -> str | None:
    if not markdown.startswith("---\n") and not markdown.startswith("---\r\n"):
        return None

    # Extract the first frontmatter block only.
    # This is intentionally a minimal parser (we only need `description:`).
    match = re.match(r"^---\s*\n(.*?)\n---\s*\n", markdown, flags=re.DOTALL)
    if not match:
        return None

    frontmatter = match.group(1)
    for line in frontmatter.splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        m = re.match(r"^description:\s*(.*)$", line)
        if m:
            return _strip_surrounding_quotes(m.group(1).strip())
    return None


def _gather_prompts(prompts_dir: Path) -> list[PromptInfo]:
    prompts: list[PromptInfo] = []
    for path in sorted(prompts_dir.glob("*.md")):
        name = path.stem
        markdown = path.read_text(encoding="utf-8")
        description = _parse_description_from_frontmatter(markdown) or name
        prompts.append(PromptInfo(name=name, description=description))
    return prompts


def _render_command_file(prompt: PromptInfo) -> str:
    description = _toml_escape_string(prompt.description)
    installed_path = f"{GEMINI_INSTALLED_PROMPTS_DIR}/{prompt.name}.md"

    lines: list[str] = []
    lines.append("# Generated by scripts/generate_gemini_commands.py")
    lines.append(f"# Command: /prompts:{prompt.name}")
    lines.append("")
    lines.append(f'description = "{description}"')
    lines.append('prompt = """')
    lines.append(f"!{{cat {installed_path}}}")
    lines.append("")
    lines.append("User Arguments ($ARGUMENTS): {{args}}")
    lines.append('"""')
    return "\n".join(lines).rstrip() + "\n"


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument("--prompts-dir", default=PROMPTS_DIR_DEFAULT)
    parser.add_argument("--out-dir", default=OUTPUT_DIR_DEFAULT)
    args = parser.parse_args()

    repo_root = Path(os.getcwd())
    prompts_dir = (repo_root / args.prompts_dir).resolve()
    out_dir = (repo_root / args.out_dir).resolve()

    prompts = _gather_prompts(prompts_dir)

    out_dir.mkdir(parents=True, exist_ok=True)
    for prompt in prompts:
        out_path = out_dir / f"{prompt.name}.toml"
        out_path.write_text(_render_command_file(prompt), encoding="utf-8")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
